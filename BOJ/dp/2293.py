import sys
input = sys.stdin.readline
# 동적 계획법(Dynamic Programming, DP)은 최적화 문제를 해결하는 알고리즘
# '전체의 문제'를 '부분 문제'로 잘 나누었는가?
#   그렇다면 전체 문제를 해결하기 위한 부분 문제의 점화식은 무엇인가?
# 부분 문제들을 해결하며 얻는 결과값을 메모이제이션하는가?
# 부분 문제의 점화식은 부분 문제들 사이의 '관계'를 빠짐없이 고려하는가?

# 처음에는 동전 개수가 k개인 경우의 수를 구하려 했지만 아니고 가치가 k인 경우의 수
# '가치의 합이 k원이 되는 경우의 수'를 구하는 전체의 문제를, '가치의 합이 i (1 ≤ i ≤ k)원이 되는 경우의 수'를 구하는 부분 문제로 나눈다.
# 추가적으로 부분 문제를 더욱 세부적으로 나눌 것인데, '특정 동전을 썼을 때 가치의 합이 i원이 되는 경우의 수'를 구하는 부분 문제로 나눈다.
# 위에서 언급한 부분 문제들을 해결해나가며 메모이제이션을 할 것인데,
# 시간 제한이 0.5초이며 메모리 제한도 4MB밖에 되지 않기 때문에 하나의 리스트 안에서 덮어 씌우는 식으로 빠르게 해결해나가야 한다.

n, k = map(int, input().split())
c = [int(input()) for i in range(n)] # 코인의 종류
dp = [0 for i in range(k+1)] # 사이즈 k+1만큼의 리스트 선언
dp[0] = 1 # 인덱스 0은 동전을 1개만 쓸 때의 경우의 수를 고려하기 위해 선언

for i in c:
    for j in range(i, k+1):
        if j-i >= 0: # 가치가 5일 때, dp[4]에 대한 고려는 안해도된다.
            dp[j] += dp[j-i]

print(dp[k])


# 3 10
# 1
# 2
# 5

# 동전 개수 1
# 0

# 2
# 5 5, dp[2] = 1
# 1

# 3
# 1, dp[3] = 1

# 4
# 5 2 2 1, dp[4] = 2
# 2

# 5
# 2 2 2 2 2, dp[5] = 3
# 5 2 1 1 1, dp[5] = 4

# 6
# 1 1 2 2 2 2, dp[6] = 5
# 5, 1,1,1,1,1, dp[6] = 6

# 7
# 2 2 2 1 1 1 1, dp[7] = 7

# 8
# 2 2 1 1 1 1 1 1, dp[8] = 8

# 9
# 2 1 1 1 1 1 1 1 1, dp[9] = 9

# 10
# 1 1 1 1 1 1 1 1 1 1, dp[10] = 10
